package org.my.process;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.sql.Timestamp;import java.util.Date;import java.util.Iterator;import java.util.List;import com.itextpdf.forms.PdfAcroForm;import com.itextpdf.forms.fields.PdfFormField;import com.itextpdf.kernel.geom.PageSize;import com.itextpdf.kernel.pdf.PdfDocument;import com.itextpdf.kernel.pdf.PdfReader;import com.itextpdf.kernel.pdf.PdfWriter;import com.itextpdf.layout.Document;import com.itextpdf.layout.element.Table;import com.itextpdf.layout.layout.LayoutArea;import com.itextpdf.layout.layout.LayoutResult;import com.itextpdf.layout.properties.UnitValue;import com.itextpdf.layout.renderer.DocumentRenderer;import com.itextpdf.layout.renderer.IRenderer;import org.adempiere.exceptions.AdempiereException;import org.apache.poi.hssf.usermodel.HSSFCell;import org.apache.poi.hssf.usermodel.HSSFDataFormatter;import org.apache.poi.hssf.usermodel.HSSFRow;import org.apache.poi.hssf.usermodel.HSSFSheet;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.ss.usermodel.Cell;import org.apache.poi.ss.usermodel.CellStyle;import org.apache.poi.ss.usermodel.CellType;import org.apache.poi.ss.usermodel.CreationHelper;import org.apache.poi.ss.usermodel.DateUtil;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.ss.util.CellReference;import org.compiere.process.ProcessInfoParameter;import org.compiere.process.SvrProcess;import org.compiere.util.DB;import com.lowagie.text.DocumentException; 		/**	 * THIS REFERS TO FACTACCTREPORT.XLS PLS REFER NOTES THERE	 * SHEETS: INPUT, PROCESS, OUTPUT 	 * INPUT IS ACTUAL LAYOUT WITH ANNOTATIONS	 * OUTPUT IS WELL DESIGNED COLORED LAYOUT TO BE WRITTEN	 * PROCESS SHEET SAMPLE SHOWN BELOW AS PLACEHOLDER CHECK BEFORE OUTPUT	 * ANNOTATION	ADDRESS	SELECT					WHERE = ?	PRE WHERE FULL SQL	Total?	VALUES		NOTES	 * @docno@		=H1		v_docno.documentno		record_id						N		1	2	3	each record ID is same DocumentNo  MANY SINGLE.	 * @dateacct@	=N7		fact_acct.dateacct		record_id						N		1	2	3	.. but other fields maybe MANY TO ONE to Record ID	 * @budget@	=P7		fact_acct.amtcr							C_Period_ID<1000012	Y		1			if Period or Amt it is totalled 	 * 															AND postingtype='B'			 * @description@=D6	fact_acct.description	record_id							N		1	2	3	Period SQL in full permanently cos.. 	 * @period@			fact_acct.c_period_ID	record_id							N		1			..annual fiscal year IDs are known					 * @amtcr@		=H6		fact_acct.amtcr	record_id								Y		1								 * @amtdr@		=G6		fact_acct.amtdr	record_id								Y		1								 * @author red1org@gmail.com Redhuan D. Oon for MOTIVE SOLUTIONS THAILAND	 *	 */	public class ExpenseReport extends SvrProcess {		private String File_Directory = "/home/red1/Documents/FactAcctReport.xls"; 		Timestamp DateFrom = null;		Timestamp DateTo = null;		HSSFDataFormatter dataFormatter = new HSSFDataFormatter();		HSSFWorkbook workbook = new HSSFWorkbook();   		String direction = "";		final static int vcol = 8;		static String DOWN = "#V";		static String LEFT = "#<";		static String RIGHT = "#>";		static String END = "END";		int lastrowwrite = 1;		int lastrowread = 0; 		String documentno = "";		long start = System.currentTimeMillis(); 		//SET ParameterTag values for #1 From, #2 To			String from = "";		String to = "";		boolean gotSQL = true;				protected void prepare() {		ProcessInfoParameter[] para = getParameter();			for (ProcessInfoParameter p:para) {				String name = p.getParameterName();				if (p.getParameter() == null)					;				else if(name.equals("DateFrom")) 					DateFrom = p.getParameterAsTimestamp();			 				else if(name.equals("DateTo"))					DateTo = p.getParameterAsTimestamp();									else if(name.equals("File_Directory"))					File_Directory = p.getParameterAsString();			}			if (DateTo!=null)				to=DateTo.toString();			if (DateFrom!=null)				from = DateFrom.toString();		}				protected String doIt() throws Exception { 			direction = RIGHT;			FileInputStream file = new FileInputStream(File_Directory); 			workbook = new HSSFWorkbook(file); 			HSSFSheet inputsheet = workbook.getSheet("Input");			HSSFSheet processsheet = workbook.getSheet("Process"); 			HSSFSheet outputsheet = workbook.getSheet("Output");			workbook.setForceFormulaRecalculation(true); 			int norecs = 0;			List<List<Object>> results = null;			// 			clearContent(processsheet);			//			setAddress(inputsheet,processsheet); 			//			while (gotSQL) { //there is a running tracker lastrowread / lastrowwrite				String completeStatement = makeFullSQLStatement(processsheet);				// 				results = executeSQL(completeStatement);				norecs+=results.size();				//				if (results!=null){					set(results,processsheet);					if (crosstab)						crosstab(processsheet,outputsheet);					paint(processsheet,outputsheet);				}			}			// 			doPDF();			//workbookWrite();			//workbookClose();			//			long finish = System.currentTimeMillis();			long timeElapsed = finish - start;			return norecs+" Records. Time Elapsed: "+timeElapsed;		} 				static boolean crosstab;   		String crossTabHoldSQL = "";		/** 		 * CROSSTAB feature - for '#?..;' advice in WHERE of Process Sheet 		 * When it is flagged during MakeFullSQL,		 * it shall store the SQL in crosstabMATRIX, then minus the SELECTion 		 * SELECT - name in the row 		 * WHERE  - add conditions to address set 		 * replace result with progressive values  		 * Paint not done here 		 *  		 * EXAMPLE: //a.DateTrx = [C8] AND (b.Value = [N4] OR b.Value = [O4]) 		 * 1. WHERE .. AND b.Value=(content of Cell N4) AND a.DateTrx<(content in Cell C8) 		 * 2. extra WHERE SQL add is fully qualified 		 * 3. NOTE Painting is thus same taking from Process Values. 		 * 4. Later we can do 'jumping' cells as stipulated by address gap. 		 *  		 * This means the Values in Process Sheet are written twice.  		 * Second pass is the right one. 		 * Programmer sanity first :D 		 *		 * @param processsheet		 * @param outsheet		 */ 		private void crosstab(HSSFSheet processsheet, HSSFSheet outsheet) {			/**TODO REFER THIS FOR CODE NAMES BELOW WHEN PARSE			 * 			 *  #?a.DateTrx = [C8] AND (b.Value = [N4] OR b.Value = [O4]);			 *  PARSE TO			 *  AND a.DateTrx < '22/02/22' AND (b.Value = '601000' OR b.Value = '602000')			 *  			 * TODO			 *  **/			//loop between last row write and last row read i.e. 1 to 23			//to look for cross tab statements in WHERE 			String ori;  			StringBuilder activeSQL; 			HSSFRow rowPr;			HSSFCell cellPr;			String SELECT;   			String C8;			String cell5value; 			String hash2comma;			String h2cbuffer = null;			HSSFCell selectcell;			HSSFRow outrow;			HSSFCell outcell;			int open;			int close;  			List<List<Object>> result; 						/************************* TAKE SQL WITHOUT SELECTION, START FROM ***********/			ori = crossTabHoldSQL.trim(); 			if (ori.indexOf(" FROM")==-1)				throw new AdempiereException("NO ' FROM' IN ORIGINAL SQL "+ori);			/*********** LOOK FOR EACH CROSSTAB THRU EACH ROW WITHIN LAST SET ************/			for (int a=lastrowwrite;a<lastrowread;a++) {				activeSQL = new StringBuilder(ori.substring(ori.indexOf(" FROM")));								rowPr = processsheet.getRow(a);				cellPr = rowPr.getCell(5);				if (cellPr.getStringCellValue().contains("#?")) {					/*********************** REMOVE MARKINGS #? ... ; ********************/					cell5value = cellPr.getStringCellValue() ;					hash2comma = cell5value.substring(2,cell5value.length()-1);					hash2comma = hash2comma.trim(); 										/************************* SELECT NAME ************************/					selectcell = rowPr.getCell(2);// third column					if (selectcell==null)						throw new AdempiereException("NO NAME IN SELECT ROW OF PROCESS SHEET");					SELECT = selectcell.getStringCellValue(); 										/**************** ACTIVE SQL BEGIN ***************************/					activeSQL = new StringBuilder("SELECT "+SELECT).append(activeSQL);					if (ori.contains("WHERE"))						activeSQL.append(" AND ");										h2cbuffer = hash2comma; 					//parse main statement					//replace address [C8] with referred displayed value 						/*************** CHECK FOR (C8) EXISTENCE ****************************/					open = h2cbuffer.indexOf("[");					close = h2cbuffer.indexOf("]");					while (open+close>0) {												/************* C8 ... N4  ******************************/						C8 = h2cbuffer.substring(open+1, close); //C8						h2cbuffer = h2cbuffer.replaceFirst("\\[","'").replaceFirst("\\]","'");//cutting off when taken from front 												//get  CROSSTAB address in Output Sheet						CellReference ref = new CellReference(C8);						//get value from address put into SQLRow outrow = outsheet.getRow(ref.getRow());						Object valueC8 = null;						outrow = outsheet.getRow(ref.getRow());						if (outrow==null)							throw new AdempiereException("CROSSTAB - OUTPUT SHEET NULL ROW: "+ref.getRow()+" WHERE "+hash2comma);						   	outcell = outrow.getCell(ref.getCol());						if (outcell == null) 							throw new AdempiereException("CROSSTAB - OUTPUT SHEET NULL CELL: "+ref.getCol()+" WHERE "+hash2comma);							outcell = outrow.getCell(ref.getCol());  						if (outcell.getCellType()==CellType.NUMERIC) {							if (DateUtil.isCellDateFormatted(outcell)) {								/*								 * cellStyle.setDataFormat(    						createHelper.createDataFormat().getFormat("m/d/yy h:mm"));								 */								CellStyle cellStyle = workbook.createCellStyle();								CreationHelper createHelper = workbook.getCreationHelper();								cellStyle.setDataFormat(								    createHelper.createDataFormat().getFormat("yyyy-mm-dd h:mm"));								outcell.setCellStyle(cellStyle);								valueC8 = outcell; 				                h2cbuffer = h2cbuffer.replaceFirst(C8,valueC8.toString());				            } else {				            	String str = valueC8.toString();  				            	h2cbuffer = h2cbuffer.replaceFirst("'"+C8+"'",str);				            }						}else  							h2cbuffer = h2cbuffer.replaceFirst(C8,outcell.getStringCellValue());													/*************** CHECK FOR NEXT (C8) EXISTENCE ****************************/						open = h2cbuffer.indexOf("[");						close = h2cbuffer.indexOf("]");					} /************************ END METHOD *******************/					activeSQL.append(h2cbuffer);					crosstab=false; int v=vcol;					result = executeSQL(activeSQL.toString()) ;					if (result==null) { 						continue;					}					for (List<Object>ctresult:result) {						for (Object retValue:ctresult) {  							//set values to Process Row second time							 								if (retValue==null)									retValue="NULL";								if (rowPr.getCell(v)==null)									rowPr.createCell(v);								 	cellPr = rowPr.getCell(v);  									String cellValue = dataFormatter.formatCellValue(cellPr); 								if (cellValue.equals(END) && v>vcol+2) //avoid accident with bottom END on first 7th column									return;								//check if numeric								 if (retValue instanceof String) { //STRING TYPE ++++									 if (String.valueOf(retValue).equals(cellPr.toString()))										continue;//same string, stop writing further										else {	 												cellPr.setCellValue((String)retValue);											System.out.println(cellPr.getAddress()+" CROSSTAB String "+retValue);										}								 }else if (retValue instanceof Timestamp) {									 if (retValue.equals(cellPr.getLocalDateTimeCellValue()))											continue;//same string, stop writing further											else {	 													cellPr.setCellValue((Timestamp)retValue); 												System.out.println(cellPr.getAddress()+" CROSSTAB Timestamp "+retValue);											}								 }								 else {//NUMERIC ++++									//double celltotal = cellPr.getNumericCellValue();								 	String str = retValue.toString(); 								 	double d = Double.valueOf(str).doubleValue(); 									cellPr.setCellValue(d); //for both cases									System.out.println(cellPr.getAddress()+" CROSSTAB Numeric "+retValue);										 }								 v++;						} 					}/***************** FINAL IN CROSSTAB MARKED #? .. ; FOR LOOP ************************/				}			} 					crossTabHoldSQL = "";			crosstab=false;		}				/**		 * Address Column and Values Column in Process Sheet		 * @param prsheet		 * @throws IOException		 */		private void clearContent(HSSFSheet prsheet) throws IOException { 			Iterator<Row> rowIteratePrClear = prsheet.rowIterator(); 				rowIteratePrClear.next();//skip label header			while (rowIteratePrClear.hasNext()) {  				int col = vcol;				HSSFRow rowPr = (HSSFRow)rowIteratePrClear.next();//row 2 until END				//				// clear column 2 of address				HSSFCell cell1 = rowPr.getCell(1);				if (cell1!=null)					cell1.setBlank();								HSSFCell cellPr = rowPr.getCell(col);				if (cellPr==null)					break;				if (!(cellPr.getCellType()==CellType.NUMERIC) &&  (cellPr.getStringCellValue()).equals(END))					break; //break when start cell in row is END. 							while (true) {						if (cellPr==null)						break;					if (!(cellPr.getCellType()==CellType.NUMERIC) &&  cellPr.getStringCellValue().equals(END)) {						break;					}					cellPr.setBlank();					col++;					cellPr = rowPr.getCell(col);				}			}			workbookWrite();		}			/**		 * Get Location on Input Sheet as Address Values in Process Sheet Column 2		 * @param recordIDs 		 * @param sheet		 */		private void setAddress(HSSFSheet insheet,HSSFSheet prsheet) {						Iterator<Row> rowIteratePr = prsheet.rowIterator(); 			boolean nothing = true;			rowIteratePr.next();//skip label header			while (rowIteratePr.hasNext()) { //loop thru every row				HSSFRow rowPr = (HSSFRow)rowIteratePr.next();					HSSFCell annotate = rowPr.getCell(0); 				if (annotate==null || annotate.toString().isBlank())					break;				String annotateValue = annotate.getRichStringCellValue().toString();				HSSFCell addressPr = rowPr.getCell(1);//Cell to store address of input annotation				if (addressPr==null) {					rowPr.createCell(1);  			//initialize cell if null					addressPr=rowPr.getCell(1);				}				//Search address in input sheet				Iterator<Row> rowIterateIn = insheet.rowIterator(); //go thru input rows				//				while(rowIterateIn.hasNext()) {  					HSSFRow rowIn = (HSSFRow)rowIterateIn.next();						Iterator<Cell> cellIterateIn = rowIn.cellIterator();					while(cellIterateIn.hasNext()) {						HSSFCell cellIn = (HSSFCell) cellIterateIn.next();						String cellInValue = cellIn.getRichStringCellValue().toString();												if (cellInValue.equals(annotateValue)) {							nothing = false;							//set to process sheet							addressPr.setCellValue(cellIn.getAddress().toString()); 							//  						 							break;						}						}				}			}			if (nothing)				throw new AdempiereException("Nothing was painted. Do INPUT sheet again");		}				/**		 * Formulate a Fully Qualified SQL Statement for Execution		 * @param prsheet		 * @return		 */		private String makeFullSQLStatement(HSSFSheet prsheet) {				 			StringBuilder fullSQL 		= new StringBuilder(); 			StringBuilder SELECT 		= new StringBuilder();			StringBuilder TABLE 		= new StringBuilder();			StringBuilder JOIN 			= new StringBuilder(); 			StringBuilder WHERE 		= new StringBuilder();						boolean gothruall 			= false; 			Iterator<Row> rowIteratePr 	= prsheet.rowIterator(); 						for (int r=0;r<lastrowwrite;r++) {				rowIteratePr.next();//row tracker starts at 1 and shall be running number			} 			HSSFRow rowPr = null;			while (rowIteratePr.hasNext()) { //loop thru every row				rowPr = (HSSFRow)rowIteratePr.next();									if (rowPr.getCell(2)==null) {					gotSQL = false; //will break out from entire process as EOF reached					break; //Leave, SELECT column ends or empty means no more lines.				} 								if (gothruall) { // #########################################################################										// ********** CHECK IF NEW SQL NEXT, THEN RETURN TO WRITE FIRST AND COME BACK *****					if (rowPr.getCell(3).toString().endsWith(" a")) { 	//meets another new set of Tables						gothruall=false; //implied  		//..so exit to process SQL then return 												// ############ FORM FULL SQL AND REPLACE #1,#2,.. WITH PARAMETERS						fullSQL.append("SELECT "+SELECT).append(" FROM "+TABLE).append(" WHERE "+JOIN).append(" "+WHERE);						fullSQL = replaceParameterTag(fullSQL, from, to);							String complete  = fullSQL.toString();						return complete;											}//*********************************************************************************										SELECT.append(","+rowPr.getCell(2).toString());					if (rowPr.getCell(3)!=null) {						if (rowPr.getCell(3).toString().contains("JOIN")) { // INNER/LEFT/RIGHT/OUTER JOINS							TABLE.append(" "+rowPr.getCell(3).toString());							if (TABLE.toString().contains(" a,")) //Checking if JOIN has an alias+coma before								throw new AdempiereException("Tables has coma and JOIN: "+TABLE.toString());						}						else {							if (!rowPr.getCell(3).toString().isEmpty())								TABLE.append(","+rowPr.getCell(3).toString());												}						if (rowPr.getCell(4)!=null) {							if (!rowPr.getCell(4).toString().isEmpty())								JOIN.append(" "+rowPr.getCell(4).toString());							}						if (rowPr.getCell(5)!=null) {							if (!rowPr.getCell(5).toString().isEmpty())								if (rowPr.getCell(5).toString().contains("#?")) 									//CROSSTAB feature - parse add snip SQL and pass more during Results									crosstab = true;								WHERE.append(" "+rowPr.getCell(5).toString());							}					}										continue; //picking up more SQL bits				} else // ###################################################################################					SELECT = new StringBuilder(rowPr.getCell(2).toString());									if (rowPr.getCell(3)!=null)					TABLE = new StringBuilder (rowPr.getCell(3).toString());								if (rowPr.getCell(4)!=null)					JOIN = new StringBuilder (rowPr.getCell(4).toString());				 				if (rowPr.getCell(5)!=null) {					if (rowPr.getCell(5).toString().contains("#?")) 						//CROSSTAB feature - parse add snip SQL and pass more during Results						crosstab = true;					WHERE = new StringBuilder (rowPr.getCell(5).toString());				}								if (!gothruall)					if (TABLE.toString().endsWith(" a")) {						gothruall=true;					}			}			// ############ FORM FULL SQL AND REPLACE #1,#2,.. WITH PARAMETERS			fullSQL.append("SELECT "+SELECT).append(" FROM "+TABLE).append(" WHERE "+JOIN).append(" "+WHERE);			fullSQL = replaceParameterTag(fullSQL, from, to);			String complete = checkCrossTab(fullSQL);			if (!rowIteratePr.hasNext())				gotSQL=false; //you run out of SQL lines in Process Sheet, so don't come back ! :)			return complete;		}		private String checkCrossTab(StringBuilder fullSQL) {			String complete  = fullSQL.toString();			if (crosstab) { //CROSSTAB feature				//repeat SQL with column progression and add to results  				complete =complete .replaceAll("#\\?.*?;", "");				crossTabHoldSQL=complete;  			}			return complete;		}				private List<List<Object>> executeSQL(String SQL) {			List<List<Object>> result =  DB.getSQLArrayObjectsEx(get_TrxName(),SQL);			if (result==null || result.isEmpty() || result.size()==0) {				System.out.println(SQL.toString()+" RETURNS NOTHING");				return null;			}			if (result.size()==1) {				Object obj = result.get(0);				if (obj.toString().equals("[0.00]")) {				 		System.out.println(SQL.toString()+" RETURNS NOTHING");				 		return null;				}			}			return result;		}		/*	 * Set DB returned RESULTS from Full SQL down wise by row	 * Down wise because the RESULTS matrix orientation	 */	private void set(List<List<Object>> results, HSSFSheet prsheet) {		int v = vcol;		for (List<Object> returning:results) { 			Iterator<Row> rowIteratePr = prsheet.rowIterator();    			for (int r=0;r<lastrowwrite;r++) {				rowIteratePr.next();//row tracker starts at 1 and shall be running number			}			boolean done = setReturnValues(prsheet,rowIteratePr, returning, v); 			v++; //column to write returned values starting from 7 to the END			if (done)				return;  		}		 lastrowwrite = lastrowread+1;	}	private void paint(HSSFSheet prsheet, HSSFSheet outsheet) {		//take column "Address" as ready array		Iterator<Row> rowIteratePr = prsheet.rowIterator();  		rowIteratePr.next();//skip label header		while (rowIteratePr.hasNext()) {  			int nc = vcol;//column VALUEs start at 7			HSSFRow rowPr = (HSSFRow)rowIteratePr.next(); 			//search address in insheet			HSSFCell addressPr = rowPr.getCell(1); 			if (rowPr.getCell(0)==null)				break;			String annotation = rowPr.getCell(0).toString(); 			if (addressPr==null|| addressPr.toString().isBlank())				continue;			//fetch values from prSheet			CellReference ref = new CellReference(addressPr.getStringCellValue());			Row outrow = outsheet.getRow(ref.getRow());			if (outrow==null)				outrow = outsheet.createRow(ref.getRow());			   Cell outcell = outrow.getCell(ref.getCol());			if (outcell == null) 				outcell = outrow.createCell(ref.getCol());  			//			//holder for row to go DOWN			int downrow = outrow.getRowNum();			Row outwriterow = outrow;						//fetch/write VALUEs to outputsheet    			boolean prValueNotEnd = true;			HSSFCell prValue = rowPr.getCell(nc);			while (prValueNotEnd) {  				if (prValue == null)					break;				if (prValue.toString().equals(END))					break;								if (prValue.getCellType()==CellType.FORMULA)					continue;				if (prValue.getCellType()==CellType.NUMERIC) { 					   outcell.setCellValue(prValue.getNumericCellValue());							   				   } else {					   outcell.setCellValue(prValue.getStringCellValue());				   }				outcell.setCellStyle(prValue.getCellStyle());								//get next value writing - 				//there is RIGHT AND DOWN direction to display subsequent records				if (annotation.endsWith(DOWN)){ //DOWNWARDS					downrow++;					outwriterow = outsheet.getRow(downrow);					outcell = outwriterow.getCell(outcell.getColumnIndex());					//					if (outwriterow.getCell(outcell.getColumnIndex())==null)						outcell = outwriterow.createCell(outcell.getColumnIndex());					else						outcell = outwriterow.getCell(outcell.getColumnIndex());									} else { //continue RIGHT-WISE					if (outrow.getCell(outcell.getColumnIndex()+1)==null)						outcell = outrow.createCell(outcell.getColumnIndex()+1);					else						outcell = outrow.getCell(outcell.getColumnIndex()+1);				}				nc++;				prValue = rowPr.getCell(nc);				//			}//LOOP OUTCELL WITHIN OUTROW ++++		} 	}	private void workbookWrite() throws IOException {		 		FileOutputStream out = new FileOutputStream(File_Directory);		if(out!=null)		{			workbook.write(out);			out.close();		}	}		void workbookClose() throws IOException { 		workbook.close();	}		/*	 * If done return true. False means continue looping by parent	 */	private boolean setReturnValues(HSSFSheet prsheet, Iterator<Row> rowIteratePr, List<Object> returns, int v) { 		for (Object retValue:returns) {			if (retValue==null)				retValue="NULL";			if (!rowIteratePr.hasNext())				return false;			HSSFRow rowPr = (HSSFRow)rowIteratePr.next();			if (rowPr.getCell(v)==null)				rowPr.createCell(v);			HSSFCell cellPr = rowPr.getCell(v);  							//by pass Cross Tab set			HSSFCell checkXT = rowPr.getCell(5);			if (checkXT.getStringCellValue().contains("#?"))				continue;						String cellValue = dataFormatter.formatCellValue(cellPr); 			if (cellValue.equals(END) && v>vcol+2) //avoid accident with bottom END on first 7th column				return true;						//check if numeric			 if (retValue instanceof String) { //STRING TYPE ++++				 if (String.valueOf(retValue).equals(cellPr.toString()))					continue;//same string, stop writing further					else {	 							cellPr.setCellValue((String)retValue);						System.out.println(cellPr.getAddress()+" Address is String "+retValue);					}			 }else if (retValue instanceof Timestamp) {				 if (retValue.equals(cellPr.getLocalDateTimeCellValue()))						continue;//same string, stop writing further						else {	 								cellPr.setCellValue((Timestamp)retValue); 							System.out.println(cellPr.getAddress()+" Address is Timestamp "+retValue);						}			 }			 else {//NUMERIC ++++				//double celltotal = cellPr.getNumericCellValue();			 	String str = retValue.toString(); 			 	double d = Double.valueOf(str).doubleValue(); 				cellPr.setCellValue(d); //for both cases				System.out.println(cellPr.getAddress()+" Address is Numeric "+retValue);					 } 				lastrowread = rowPr.getRowNum();		 }		return false;	}		private StringBuilder replaceParameterTag(StringBuilder whereCondition, String from, String to) {		String s = "";		if (whereCondition.toString().contains("#")){			s = whereCondition.toString().replace("#1","\'"+from+"\'"); 			whereCondition = new StringBuilder(s.replace("#2","\'"+to+"\'"));		}		return whereCondition;	} 	   	boolean flag = true;	private int temp;	private short numberOfColumns;		/**	 * 	 * @throws IOException	 * @throws DocumentException	 */	void doPDF() throws IOException{				//First we read the Excel file in binary format into FileInputStream         // Read worksheet into HSSFSheet        HSSFSheet my_worksheet = workbook.getSheet("Output");         // To iterate over the rows        Iterator<Row> rowIterator = my_worksheet.rowIterator();        String File_Directory_PDF = File_Directory.replace("xls", "pdf");        final PdfWriter pdfWriter = new PdfWriter(File_Directory_PDF);        final PdfDocument pdfDoc = new PdfDocument(pdfWriter);        Document doc = new Document(pdfDoc,PageSize.A2.rotate());                HSSFRow initrow = (HSSFRow) rowIterator.next();         Table table = new Table(initrow.getLastCellNum());  	    table.setWidth(UnitValue.createPercentValue(100));                   while(rowIterator.hasNext()) {        	int cellNumber = 0;         HSSFRow row = (HSSFRow) rowIterator.next();          Iterator<Cell> cellIterator = row.cellIterator();     	         while(cellIterator.hasNext()) {       	// For each row, iterate through each columns 				Cell cell = cellIterator.next();				switch (cell.getCellType()) {  				case STRING:					if (temp == 0) { 						numberOfColumns = row.getLastCellNum();						table.addCell(cell.getStringCellValue());                    }else{                           cellNumber =checkEmptyCellAndAddCellContentToPDFTable(cellNumber,cell,table);                    }                    cellNumber++;                    break;				case NUMERIC:                    cellNumber =checkEmptyCellAndAddCellContentToPDFTable(cellNumber,cell,table);                    cellNumber++;                    break;				case FORMULA:                    cellNumber =checkEmptyCellAndAddCellContentToPDFTable(cellNumber,cell,table);                    cellNumber++;					break;				default:					break;				}             }         table.startNewRow();         temp = 1;    	if(numberOfColumns != cellNumber){                for(int i=0;i<(numberOfColumns-cellNumber);i++){                            table.addCell(" ");                }    		}		}        doc.add(table);        doc.close();	}		private static int checkEmptyCellAndAddCellContentToPDFTable(int cellNumber, Cell cell, Table table) {	        if (cellNumber == cell.getColumnIndex()) { 	        	if(cell.getCellType() == CellType.NUMERIC){ 	        		table.addCell(Double.toString(cell.getNumericCellValue())); 	        		}             if(cell.getCellType() == CellType.STRING){             	table.addCell(cell.getStringCellValue());            	}                          if(cell.getCellType() == CellType.FORMULA) {                System.out.println("Formula is " + cell.getCellFormula());                switch(cell.getCachedFormulaResultType()) {                    case NUMERIC:                        table.addCell(Double.toString(cell.getNumericCellValue()));                         break;                    case STRING:                        table.addCell(cell.getStringCellValue());                        break;                }             }              } else {         	while( cellNumber < cell.getColumnIndex()) {        	  table.addCell(" ");        	  cellNumber++;         	}        	if (cellNumber == cell.getColumnIndex()) {        		if(cell.getCellType() == CellType.NUMERIC){         		  table.addCell(Double.toString(cell.getNumericCellValue()));        		}        		if(cell.getCellType() == CellType.STRING){           			table.addCell(cell.getStringCellValue());        		}	            if(cell.getCellType() == CellType.FORMULA) {	                System.out.println("Formula is " + cell.getCellFormula());	                switch(cell.getCachedFormulaResultType()) {	                    case NUMERIC:	                        table.addCell(Double.toString(cell.getNumericCellValue())); 	                        break;	                    case STRING:	                        table.addCell(cell.getStringCellValue());	                        break;	                }	             }        	}        	cellNumber = cell.getColumnIndex();        }          return cellNumber;	}}