package org.my.process;
import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException; import java.sql.Timestamp;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import org.adempiere.exceptions.AdempiereException; import org.apache.poi.hssf.usermodel.HSSFCell;import org.apache.poi.hssf.usermodel.HSSFDataFormatter;import org.apache.poi.hssf.usermodel.HSSFRow;import org.apache.poi.hssf.usermodel.HSSFSheet;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.ss.util.CellReference;import org.apache.poi.ss.usermodel.Cell;import org.apache.poi.ss.usermodel.CellType;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.ss.util.CellAddress;import org.compiere.model.MFactAcct;import org.compiere.model.Query;import org.compiere.process.ProcessInfoParameter;
import org.compiere.process.SvrProcess;import org.compiere.util.DB;
		/**	 * THIS REFERS TO FACTACCTREPORT.XLS PLS REFER NOTES THERE	 * SHEETS: INPUT, PROCESS, OUTPUT 	 * INPUT IS ACTUAL LAYOUT WITH ANNOTATIONS	 * OUTPUT IS WELL DESIGNED COLORED LAYOUT TO BE WRITTEN	 * PROCESS SHEET SAMPLE SHOWN BELOW AS PLACEHOLDER CHECK BEFORE OUTPUT	 * ANNOTATION	ADDRESS	SELECT					WHERE = ?	PRE WHERE FULL SQL	Total?	VALUES		NOTES	 * @docno@		=H1		v_docno.documentno		record_id						N		1	2	3	each record ID is same DocumentNo  MANY SINGLE.	 * @dateacct@	=N7		fact_acct.dateacct		record_id						N		1	2	3	.. but other fields maybe MANY TO ONE to Record ID	 * @budget@	=P7		fact_acct.amtcr							C_Period_ID<1000012	Y		1			if Period or Amt it is totalled 	 * 															AND postingtype='B'			 * @description@=D6	fact_acct.description	record_id							N		1	2	3	Period SQL in full permanently cos.. 	 * @period@			fact_acct.c_period_ID	record_id							N		1			..annual fiscal year IDs are known					 * @amtcr@		=H6		fact_acct.amtcr	record_id								Y		1								 * @amtdr@		=G6		fact_acct.amtdr	record_id								Y		1								 * @author red1org@gmail.com Redhuan D. Oon for MOTIVE SOLUTIONS THAILAND	 *	 */
	public class ExpenseReport extends SvrProcess {
		private String File_Directory = "/home/red1/Documents/FactAcctReport.xls"; 		Timestamp DateFrom = null;		Timestamp DateTo = null;		HSSFDataFormatter dataFormatter = new HSSFDataFormatter();
		HSSFWorkbook workbook = new HSSFWorkbook();   		String direction = "";		static String UP = "#^";		static String DOWN = "#V";		static String LEFT = "#<";		static String RIGHT = "#>";		static String END = "END";		int rowtracker = 0;		int coltracker = 0;		String documentno = "";				protected void prepare() {
		ProcessInfoParameter[] para = getParameter();
			for (ProcessInfoParameter p:para) {
				String name = p.getParameterName();
				if (p.getParameter() == null)					;
				else if(name.equals("DateFrom")){
					DateFrom = p.getParameterAsTimestamp();
			}
				else if(name.equals("DateTo")){}
			}
		}		protected String doIt() throws IOException { 			// 			//OBTAIN FACTS +++++			int[] recordIDs = buildFactsRecordIDs();						if (recordIDs==null || recordIDs.length==0) 				throw new AdempiereException("No Accounting Facts Record");						direction = RIGHT;			FileInputStream file = new FileInputStream(File_Directory); 			workbook = new HSSFWorkbook(file); 			HSSFSheet inputsheet = workbook.getSheet("Input");			HSSFSheet processsheet = workbook.getSheet("Process"); 			HSSFSheet outputsheet = workbook.getSheet("Output");			workbook.setForceFormulaRecalculation(true); 			// 			updateProcess(inputsheet,processsheet,recordIDs); 			//			layoutOutput(processsheet,outputsheet);			//			writeModelSheet(processsheet);			//
			return "";
		}		private int[] buildFactsRecordIDs() {		StringBuilder buildstring = new StringBuilder();		int[] recordIDs = new int[999];		List<Object> params = new ArrayList<Object>(); 		if (DateTo!=null) {			buildstring.append(MFactAcct.COLUMNNAME_DateAcct+"<=?");			params.add(DateTo);		}		if (DateFrom!=null) {			if (buildstring.length()>0)				buildstring.append(" AND ");			buildstring.append(MFactAcct.COLUMNNAME_DateAcct+">=?");			params.add(DateFrom);		} 		if (buildstring.length()>0)			buildstring.append(" AND ");			buildstring.append(MFactAcct.COLUMNNAME_PostingType+"=?");		params.add(MFactAcct.POSTINGTYPE_Actual); 		List<MFactAcct> facts = new Query(getCtx(), MFactAcct.Table_Name, buildstring.toString(), get_TrxName())			.setParameters(params).setClient_ID().setOrderBy(MFactAcct.COLUMNNAME_Record_ID).list();		int i=0;		for (MFactAcct fact:facts) {			recordIDs[i]=fact.getRecord_ID();			i++;		}		System.out.println(i+" recordIDs");		return recordIDs;	} 		/**	 * SEE NOTES AT BEGINNING	 * @param recordIDs 	 * @param sheet	 */	private void updateProcess(HSSFSheet insheet,HSSFSheet prsheet, int[] recordIDs) {		CellAddress address = null;		Iterator<Row> rowIteratePr = prsheet.rowIterator();  		rowIteratePr.next();//skip label header		while (rowIteratePr.hasNext()) {  			HSSFRow rowPr = (HSSFRow)rowIteratePr.next();				HSSFCell annotate = rowPr.getCell(0); 			if (annotate.toString().isBlank())				break;			HSSFCell addressPr = rowPr.getCell(1);			//search address in insheet			Iterator<Row> rowIterateIn = insheet.rowIterator();  			while(rowIterateIn.hasNext()) {  				int i=0;//loop within at each SELECT STATEMENT LOOP				boolean found = false;				HSSFRow rowIn = (HSSFRow)rowIterateIn.next();					Iterator<Cell> cellIterateIn = rowIn.cellIterator();				while(cellIterateIn.hasNext()) {					HSSFCell cellIn = (HSSFCell) cellIterateIn.next();					if (cellIn.getCellType()==CellType.FORMULA)						continue;					if (cellIn.toString().equals(annotate.toString())) {						//set to process sheet						if (addressPr==null) {							rowPr.createCell(1);							addressPr=rowPr.getCell(1);						}						addressPr.setCellValue(cellIn.getAddress().toString()); 						//						//SELECT STATEMENT EXECUTE +++++ 						String whereCondition = "";						Object[] param = new Object[1];						//SWAP WHERE CONDITION 						if (rowPr.getCell(4)==null || rowPr.getCell(4).equals("")) {								whereCondition = rowPr.getCell(5).toString(); 								param=null;						}						else 	{							whereCondition = rowPr.getCell(4).toString()+"=?";							param[0] = recordIDs[i]; //usual case							i++;						}						//TODO handle no WHERE-PREWHERE condition 						StringBuilder SQL = new StringBuilder("SELECT "+rowPr.getCell(2)						+" FROM "+rowPr.getCell(3)+" WHERE "								+whereCondition);//if cell4 not blank replace / param replace also TODO						List<List<Object>> returns =  DB.getSQLArrayObjectsEx(get_TrxName(),SQL.toString(),param);						//						//handle null returns						if (returns==null) {							System.out.println(SQL.toString()+" RETURNS NOTHING");							continue;						}						//SET VALUES TO PROCESS SHEET +++++ LOOP EACH VALUE TO VALUES IN SHEET						int v = 7;						for (List<Object> returning:returns) {							Object retValue = returning.get(0);							if (rowPr.getCell(v)==null)								rowPr.createCell(v);							HSSFCell cellPr = rowPr.getCell(v);							//														String cellValue = dataFormatter.formatCellValue(cellPr); 							if (cellValue.equals("END"))								break;							//get CellValue							 if(cellPr.getCellType() == CellType.FORMULA) { 				                  switch(cellPr.getCachedFormulaResultType()) {				                    case NUMERIC:				                        cellValue= Double.toString(cellPr.getNumericCellValue());				                        break;				                    case STRING:				                        cellValue= cellPr.getRichStringCellValue().getString();				                        break;				                    case BLANK:				                    	break;									case BOOLEAN:										break;									case ERROR:										break;									case FORMULA:										break;									case _NONE:										break;									default:										break;				                  }				             }							//check if numeric							 if (retValue instanceof String) { //STRING TYPE ++++								 if (String.valueOf(retValue).equals(cellPr.toString()))									continue;//same string, stop writing further									else {	 											cellPr.setCellValue((String)retValue);										System.out.println(cellPr.getAddress()+" Address is SetCellValue "+retValue);									}							 }else if (retValue instanceof Timestamp) {								 if (retValue.equals(cellPr.getLocalDateTimeCellValue()))										continue;//same string, stop writing further										else {	 												cellPr.setCellValue((Timestamp)retValue); 											System.out.println(cellPr.getAddress()+" Address is SetCellValue "+retValue);										}							 }							 else {//NUMERIC ++++								 double celltotal = cellPr.getNumericCellValue();								  								String str = retValue.toString(); 								double d = Double.valueOf(str).doubleValue();								if (d==0.0f)									continue;																//check if Totals									if (rowPr.getCell(6).toString().equals("Y")) { //TODO total up										 //add to it										 //cell6total = cell6total+(double)retValue; 										 celltotal = celltotal+d; 										 --v;// setback to be same next round									 	}  else 									 		celltotal=d;									 cellPr.setCellValue(celltotal); //for both cases									 System.out.println(cellPr.getAddress()+" Address is Numeric "+retValue);										}							 v++; //jump to next column for next return							 	}							break;						}					 					}			 				}							}			   		}		private void layoutOutput(HSSFSheet prsheet, HSSFSheet outsheet) {		//take column "Address" as ready array		Iterator<Row> rowIteratePr = prsheet.rowIterator();  		rowIteratePr.next();//skip label header		while (rowIteratePr.hasNext()) {  			int nc = 7;//column VALUEs start at 7			HSSFRow rowPr = (HSSFRow)rowIteratePr.next(); 			//search address in insheet			HSSFCell addressPr = rowPr.getCell(1); 			String annotation = rowPr.getCell(0).toString(); 			if (addressPr==null|| addressPr.toString().isBlank())				continue;			//fetch values from prSheet			CellReference ref = new CellReference(addressPr.getStringCellValue());			Row outrow = outsheet.getRow(ref.getRow());			if (outrow==null)				outrow = outsheet.createRow(ref.getRow());			   Cell outcell = outrow.getCell(ref.getCol());			if (outcell == null) 				outcell = outrow.createCell(ref.getCol());  			//			//holder for row to go DOWN			int downrow = outrow.getRowNum();			Row outwriterow = outrow;						//fetch/write VALUEs to outputsheet    			boolean prValueNotEnd = true;			HSSFCell prValue = rowPr.getCell(nc);			while (prValueNotEnd) {  				if (prValue == null)					break;				if (prValue.toString().equals("END"))					break;								if (prValue.getCellType()==CellType.FORMULA)					continue;				if (prValue.getCellType()==CellType.NUMERIC) { 					   outcell.setCellValue(prValue.getNumericCellValue());							   				   } else {					   outcell.setCellValue(prValue.getStringCellValue());				   }				outcell.setCellStyle(prValue.getCellStyle());								//get next value writing - 				//there is RIGHT AND DOWN direction to display subsequent records				if (annotation.endsWith(DOWN)){ //DOWNWARDS					downrow++;					outwriterow = outsheet.getRow(downrow);					outcell = outwriterow.getCell(outcell.getColumnIndex());					//					if (outwriterow.getCell(outcell.getColumnIndex())==null)						outcell = outwriterow.createCell(outcell.getColumnIndex());					else						outcell = outwriterow.getCell(outcell.getColumnIndex());									} else { //continue RIGHT-WISE					if (outrow.getCell(outcell.getColumnIndex()+1)==null)						outcell = outrow.createCell(outcell.getColumnIndex()+1);					else						outcell = outrow.getCell(outcell.getColumnIndex()+1);				}				nc++;				prValue = rowPr.getCell(nc);				//			}//LOOP OUTCELL WITHIN OUTROW ++++		} 	}	private void writeModelSheet(HSSFSheet sheet) throws IOException {		 Iterator<Row> rowIterator = sheet.rowIterator();		 while (rowIterator.hasNext()) {				HSSFRow row = (HSSFRow) rowIterator.next();				HSSFCell cell = row.getCell(1);				if (cell!=null)					System.out.println(cell.getRichStringCellValue());					}			FileOutputStream out = new FileOutputStream(File_Directory);			if(out!=null)			{				workbook.write(out);				out.close();				workbook.close();			}	}
}
