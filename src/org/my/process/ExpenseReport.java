package org.my.process;
import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException; import java.sql.Timestamp;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import org.adempiere.exceptions.AdempiereException; import org.apache.poi.hssf.usermodel.HSSFCell;import org.apache.poi.hssf.usermodel.HSSFDataFormatter;import org.apache.poi.hssf.usermodel.HSSFRow;import org.apache.poi.hssf.usermodel.HSSFSheet;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.ss.util.CellReference;import org.apache.poi.ss.usermodel.Cell;import org.apache.poi.ss.usermodel.CellType;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.ss.util.CellAddress;import org.compiere.model.MFactAcct;import org.compiere.model.Query;import org.compiere.process.ProcessInfoParameter;
import org.compiere.process.SvrProcess;import org.compiere.util.DB;import org.compiere.util.ValueNamePair;
		/**	 * THIS REFERS TO FACTACCTREPORT.XLS PLS REFER NOTES THERE	 * SHEETS: INPUT, PROCESS, OUTPUT 	 * INPUT IS ACTUAL LAYOUT WITH ANNOTATIONS	 * OUTPUT IS WELL DESIGNED COLORED LAYOUT TO BE WRITTEN	 * PROCESS SHEET SAMPLE SHOWN BELOW AS PLACEHOLDER CHECK BEFORE OUTPUT	 * ANNOTATION	ADDRESS	SELECT					WHERE = ?	PRE WHERE FULL SQL	Total?	VALUES		NOTES	 * @docno@		=H1		v_docno.documentno		record_id						N		1	2	3	each record ID is same DocumentNo  MANY SINGLE.	 * @dateacct@	=N7		fact_acct.dateacct		record_id						N		1	2	3	.. but other fields maybe MANY TO ONE to Record ID	 * @budget@	=P7		fact_acct.amtcr							C_Period_ID<1000012	Y		1			if Period or Amt it is totalled 	 * 															AND postingtype='B'			 * @description@=D6	fact_acct.description	record_id							N		1	2	3	Period SQL in full permanently cos.. 	 * @period@			fact_acct.c_period_ID	record_id							N		1			..annual fiscal year IDs are known					 * @amtcr@		=H6		fact_acct.amtcr	record_id								Y		1								 * @amtdr@		=G6		fact_acct.amtdr	record_id								Y		1								 * @author red1org@gmail.com Redhuan D. Oon for MOTIVE SOLUTIONS THAILAND	 *	 */
	public class ExpenseReport extends SvrProcess {
		private String File_Directory = "/home/red1/Documents/FactAcctReport.xls"; 		Timestamp DateFrom = null;		Timestamp DateTo = null;		HSSFDataFormatter dataFormatter = new HSSFDataFormatter();
		HSSFWorkbook workbook = new HSSFWorkbook();   		String direction = "";		static String DOWN = "#V";		static String LEFT = "#<";		static String RIGHT = "#>";		static String END = "END";		int lastrowwrite = 1;		private int lastrowread = 0;		int coltracker = 0;		String documentno = "";		long start = System.currentTimeMillis();		ArrayList<ValueNamePair> arrayreturn = new ArrayList<ValueNamePair>();		//SET ParameterTag values for #1 From, #2 To			String from = "";		String to = "";		boolean gotSQL = true; 		boolean virgin = true;		// ...				protected void prepare() {
		ProcessInfoParameter[] para = getParameter();
			for (ProcessInfoParameter p:para) {
				String name = p.getParameterName();
				if (p.getParameter() == null)					;
				else if(name.equals("DateFrom")) 
					DateFrom = p.getParameterAsTimestamp();
			 
				else if(name.equals("DateTo"))					DateTo = p.getParameterAsTimestamp();									else if(name.equals("File_Directory"))					File_Directory = p.getParameterAsString();
			}			if (DateTo!=null)				to=DateTo.toString();			if (DateFrom!=null)				from = DateFrom.toString();
		}				protected String doIt() throws IOException { 			direction = RIGHT;			FileInputStream file = new FileInputStream(File_Directory); 			workbook = new HSSFWorkbook(file); 			HSSFSheet inputsheet = workbook.getSheet("Input");			HSSFSheet processsheet = workbook.getSheet("Process"); 			HSSFSheet outputsheet = workbook.getSheet("Output");			workbook.setForceFormulaRecalculation(true); 			int norecs = 0;			List<List<Object>> results = null;			// 			clearContent(processsheet);			//			setAddress(inputsheet,processsheet); 			//			while (gotSQL) { //running row tracker to give last row gotSQL status				StringBuilder completeStatement = makeFullSQLStatement(processsheet);				//				results = executeSQL(completeStatement);				norecs+=results.size();				//				if (results!=null){					set(results,processsheet);					paint(processsheet,outputsheet);					virgin = false;				}			}			//			workbookWrite();			workbookClose();			//			long finish = System.currentTimeMillis();			long timeElapsed = finish - start;			
			return norecs+" Records. Time Elapsed: "+timeElapsed;
		}			private void clearContent(HSSFSheet prsheet) throws IOException { 			Iterator<Row> rowIteratePrClear = prsheet.rowIterator(); 				rowIteratePrClear.next();//skip label header			while (rowIteratePrClear.hasNext()) {  				int col = 7;				HSSFRow rowPr = (HSSFRow)rowIteratePrClear.next();//row 2 until END				HSSFCell cellPr = rowPr.getCell(col);				if (cellPr==null)					break;				if (!(cellPr.getCellType()==CellType.NUMERIC) &&  (cellPr.getStringCellValue()).equals(END))					break; //break when start cell in row is END. 							while (true) {						if (cellPr==null)						break;					if (!(cellPr.getCellType()==CellType.NUMERIC) &&  cellPr.getStringCellValue().equals(END)) {						break;					}					cellPr.setBlank();					col++;					cellPr = rowPr.getCell(col);				}			}			workbookWrite();		}			/**		 * Get Location on Input Sheet as Address Values in Process Sheet Column 2		 * @param recordIDs 		 * @param sheet		 */		private void setAddress(HSSFSheet insheet,HSSFSheet prsheet) {						Iterator<Row> rowIteratePr = prsheet.rowIterator();  			rowIteratePr.next();//skip label header			while (rowIteratePr.hasNext()) { //loop thru every row				HSSFRow rowPr = (HSSFRow)rowIteratePr.next();					HSSFCell annotate = rowPr.getCell(0); 				if (annotate==null || annotate.toString().isBlank())					break;				String annotateValue = annotate.getRichStringCellValue().toString();				if (annotateValue.equals("@@")) //blank reference					break;				HSSFCell addressPr = rowPr.getCell(1);//Cell to store address of input annotation				if (addressPr==null) {					rowPr.createCell(1);  			//initialize cell if null					addressPr=rowPr.getCell(1);				}				//Search address in input sheet				Iterator<Row> rowIterateIn = insheet.rowIterator(); //go thru input rows				//				while(rowIterateIn.hasNext()) {  					HSSFRow rowIn = (HSSFRow)rowIterateIn.next();						Iterator<Cell> cellIterateIn = rowIn.cellIterator();					while(cellIterateIn.hasNext()) {						HSSFCell cellIn = (HSSFCell) cellIterateIn.next();						String cellInValue = cellIn.getRichStringCellValue().toString();												if (cellInValue.equals(annotateValue)) {							//set to process sheet							addressPr.setCellValue(cellIn.getAddress().toString()); 							//  						 							break;						}						}				}			}		}				/**		 * Formulate a Fully Qualified SQL Statement for Execution		 * @param prsheet		 * @return		 */		private StringBuilder makeFullSQLStatement(HSSFSheet prsheet) {				 			StringBuilder fullSQL 		= new StringBuilder(); 			StringBuilder SELECT 		= new StringBuilder();			StringBuilder TABLE 		= new StringBuilder();			StringBuilder JOIN 			= new StringBuilder(); 			StringBuilder WHERE 		= new StringBuilder();						boolean gothruall 			= false;			boolean metB 				= false;  //marker to check if next SQL present			Iterator<Row> rowIteratePr 	= prsheet.rowIterator(); 						for (int r=0;r<lastrowwrite;r++) {				rowIteratePr.next();//row tracker starts at 1 and shall be running number			} 			HSSFRow rowPr = null;			while (rowIteratePr.hasNext()) { //loop thru every row				rowPr = (HSSFRow)rowIteratePr.next();									if (rowPr.getCell(2)==null) {					gotSQL = false; //will break out from entire process as EOF reached					break; //Leave, SELECT column ends or empty means no more lines.				} 								if (gothruall) { // #########################################################################										// ********** CHECK IF NEW SQL NEXT, THEN RETURN TO WRITE FIRST AND COME BACK *****					if (rowPr.getCell(3).toString().endsWith(" a")) { 	//meets another new set of Tables						gothruall=false; //implied  		//..so exit to process SQL then return 												// ############ FORM FULL SQL AND REPLACE #1,#2,.. WITH PARAMETERS						fullSQL.append("SELECT "+SELECT).append(" FROM "+TABLE).append(" WHERE "+JOIN).append(" "+WHERE);						fullSQL = replaceParameterTag(fullSQL, from, to);												return fullSQL;											}//*********************************************************************************										SELECT.append(","+rowPr.getCell(2).toString());					if (rowPr.getCell(3)!=null) {						if (rowPr.getCell(3).toString().contains("JOIN")) { // INNER/LEFT/RIGHT/OUTER JOINS							TABLE.append(" "+rowPr.getCell(3).toString());							if (TABLE.toString().contains(" a,")) //Checking if JOIN has an alias+coma before								throw new AdempiereException("Tables has coma and JOIN: "+TABLE.toString());						}						else {							if (!rowPr.getCell(3).toString().isEmpty())								TABLE.append(","+rowPr.getCell(3).toString());												}						if (rowPr.getCell(4)!=null) {							if (!rowPr.getCell(4).toString().isEmpty())								JOIN.append(" "+rowPr.getCell(4).toString());							}						if (rowPr.getCell(5)!=null) {							if (!rowPr.getCell(5).toString().isEmpty())								WHERE.append(" "+rowPr.getCell(5).toString());							}					}										continue; //picking up more SQL bits				} else // ###################################################################################					SELECT = new StringBuilder(rowPr.getCell(2).toString());									if (rowPr.getCell(3)!=null)					TABLE = new StringBuilder (rowPr.getCell(3).toString());								if (rowPr.getCell(4)!=null)					JOIN = new StringBuilder (rowPr.getCell(4).toString());				 				if (rowPr.getCell(5)!=null)					WHERE = new StringBuilder (rowPr.getCell(5).toString());								if (!gothruall)					if (TABLE.toString().endsWith(" a")) {						gothruall=true;					}			}			// ############ FORM FULL SQL AND REPLACE #1,#2,.. WITH PARAMETERS			fullSQL.append("SELECT "+SELECT).append(" FROM "+TABLE).append(" WHERE "+JOIN).append(" "+WHERE);			fullSQL = replaceParameterTag(fullSQL, from, to);			 			if (!rowIteratePr.hasNext())				gotSQL=false; //you run out of SQL lines in Process Sheet, so don't come back ! :)			return fullSQL;		}				private List<List<Object>> executeSQL(StringBuilder SQL) {			List<List<Object>> returns =  DB.getSQLArrayObjectsEx(get_TrxName(),SQL.toString());			if (returns==null || returns.isEmpty() || returns.size()==0) {				System.out.println(SQL.toString()+" RETURNS NOTHING");				return null;			}			if (returns.size()==1) {				Object obj = returns.get(0);				if (obj.toString().equals("[0.00]")) {				 		System.out.println(SQL.toString()+" RETURNS NOTHING");				 		return null;				}			}			return returns;		}		/*	 * Set DB returned RESULTS from Full SQL down wise by row	 * Down wise because the RESULTS matrix orientation	 */	private void set(List<List<Object>> results, HSSFSheet prsheet) {		int v = 7;		for (List<Object> returning:results) { 			Iterator<Row> rowIteratePr = prsheet.rowIterator();    			for (int r=0;r<lastrowwrite;r++) {				rowIteratePr.next();//row tracker starts at 1 and shall be running number			}			boolean done = setReturnValues(prsheet,rowIteratePr, returning, v); 			v++; //column to write returned values starting from 7 to the END			if (done)				return;  		}		 lastrowwrite = lastrowread+1;	}	private void paint(HSSFSheet prsheet, HSSFSheet outsheet) {		//take column "Address" as ready array		Iterator<Row> rowIteratePr = prsheet.rowIterator();  		rowIteratePr.next();//skip label header		while (rowIteratePr.hasNext()) {  			int nc = 7;//column VALUEs start at 7			HSSFRow rowPr = (HSSFRow)rowIteratePr.next(); 			//search address in insheet			HSSFCell addressPr = rowPr.getCell(1); 			if (rowPr.getCell(0)==null)				break;			String annotation = rowPr.getCell(0).toString(); 			if (addressPr==null|| addressPr.toString().isBlank())				continue;			//fetch values from prSheet			CellReference ref = new CellReference(addressPr.getStringCellValue());			Row outrow = outsheet.getRow(ref.getRow());			if (outrow==null)				outrow = outsheet.createRow(ref.getRow());			   Cell outcell = outrow.getCell(ref.getCol());			if (outcell == null) 				outcell = outrow.createCell(ref.getCol());  			//			//holder for row to go DOWN			int downrow = outrow.getRowNum();			Row outwriterow = outrow;						//fetch/write VALUEs to outputsheet    			boolean prValueNotEnd = true;			HSSFCell prValue = rowPr.getCell(nc);			while (prValueNotEnd) {  				if (prValue == null)					break;				if (prValue.toString().equals(END))					break;								if (prValue.getCellType()==CellType.FORMULA)					continue;				if (prValue.getCellType()==CellType.NUMERIC) { 					   outcell.setCellValue(prValue.getNumericCellValue());							   				   } else {					   outcell.setCellValue(prValue.getStringCellValue());				   }				outcell.setCellStyle(prValue.getCellStyle());								//get next value writing - 				//there is RIGHT AND DOWN direction to display subsequent records				if (annotation.endsWith(DOWN)){ //DOWNWARDS					downrow++;					outwriterow = outsheet.getRow(downrow);					outcell = outwriterow.getCell(outcell.getColumnIndex());					//					if (outwriterow.getCell(outcell.getColumnIndex())==null)						outcell = outwriterow.createCell(outcell.getColumnIndex());					else						outcell = outwriterow.getCell(outcell.getColumnIndex());									} else { //continue RIGHT-WISE					if (outrow.getCell(outcell.getColumnIndex()+1)==null)						outcell = outrow.createCell(outcell.getColumnIndex()+1);					else						outcell = outrow.getCell(outcell.getColumnIndex()+1);				}				nc++;				prValue = rowPr.getCell(nc);				//			}//LOOP OUTCELL WITHIN OUTROW ++++		} 	}	private void workbookWrite() throws IOException {		 		FileOutputStream out = new FileOutputStream(File_Directory);		if(out!=null)		{			workbook.write(out);			out.close();		}	}		void workbookClose() throws IOException { 		workbook.close();	}		/*	 * If done return true. False means continue looping by parent	 */	private boolean setReturnValues(HSSFSheet prsheet, Iterator<Row> rowIteratePr, List<Object> returns, int v) { 		for (Object retValue:returns) {			if (retValue==null)				retValue="NULL";			if (!rowIteratePr.hasNext())				return false;			HSSFRow rowPr = (HSSFRow)rowIteratePr.next();			if (rowPr.getCell(v)==null)				rowPr.createCell(v);			HSSFCell cellPr = rowPr.getCell(v);  							String cellValue = dataFormatter.formatCellValue(cellPr); 			if (cellValue.equals(END) && v>8) //avoid accident with bottom END on first 7th column				return true;						//check if numeric			 if (retValue instanceof String) { //STRING TYPE ++++				 if (String.valueOf(retValue).equals(cellPr.toString()))					continue;//same string, stop writing further					else {	 							cellPr.setCellValue((String)retValue);						System.out.println(cellPr.getAddress()+" Address is String "+retValue);					}			 }else if (retValue instanceof Timestamp) {				 if (retValue.equals(cellPr.getLocalDateTimeCellValue()))						continue;//same string, stop writing further						else {	 								cellPr.setCellValue((Timestamp)retValue); 							System.out.println(cellPr.getAddress()+" Address is Timestamp "+retValue);						}			 }			 else {//NUMERIC ++++				//double celltotal = cellPr.getNumericCellValue();				//TODO Accumulate to Same Process Location?			 	String str = retValue.toString(); 			 	double d = Double.valueOf(str).doubleValue(); 				cellPr.setCellValue(d); //for both cases				System.out.println(cellPr.getAddress()+" Address is Numeric "+retValue);					 } 				lastrowread = rowPr.getRowNum();		 }		return false;	}		private StringBuilder replaceParameterTag(StringBuilder whereCondition, String from, String to) {		String s = "";		if (whereCondition.toString().contains("#")){			s = whereCondition.toString().replace("#1","\'"+from+"\'"); 			whereCondition = new StringBuilder(s.replace("#2","\'"+to+"\'"));		}		return whereCondition;	}	private void setArrayReturns(ArrayList<ValueNamePair> arrayreturn, List<List<Object>> returns) {	// TODO Auto-generated method stub		}
}
