package org.my.process;
import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException; import java.sql.Timestamp;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import org.adempiere.exceptions.AdempiereException; import org.apache.poi.hssf.usermodel.HSSFCell;import org.apache.poi.hssf.usermodel.HSSFDataFormatter;import org.apache.poi.hssf.usermodel.HSSFRow;import org.apache.poi.hssf.usermodel.HSSFSheet;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.ss.util.CellReference;import org.apache.poi.ss.usermodel.Cell;import org.apache.poi.ss.usermodel.CellType;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.ss.util.CellAddress;import org.compiere.model.MFactAcct;import org.compiere.model.Query;import org.compiere.process.ProcessInfoParameter;
import org.compiere.process.SvrProcess;import org.compiere.util.DB;import org.compiere.util.ValueNamePair;
		/**	 * THIS REFERS TO FACTACCTREPORT.XLS PLS REFER NOTES THERE	 * SHEETS: INPUT, PROCESS, OUTPUT 	 * INPUT IS ACTUAL LAYOUT WITH ANNOTATIONS	 * OUTPUT IS WELL DESIGNED COLORED LAYOUT TO BE WRITTEN	 * PROCESS SHEET SAMPLE SHOWN BELOW AS PLACEHOLDER CHECK BEFORE OUTPUT	 * ANNOTATION	ADDRESS	SELECT					WHERE = ?	PRE WHERE FULL SQL	Total?	VALUES		NOTES	 * @docno@		=H1		v_docno.documentno		record_id						N		1	2	3	each record ID is same DocumentNo  MANY SINGLE.	 * @dateacct@	=N7		fact_acct.dateacct		record_id						N		1	2	3	.. but other fields maybe MANY TO ONE to Record ID	 * @budget@	=P7		fact_acct.amtcr							C_Period_ID<1000012	Y		1			if Period or Amt it is totalled 	 * 															AND postingtype='B'			 * @description@=D6	fact_acct.description	record_id							N		1	2	3	Period SQL in full permanently cos.. 	 * @period@			fact_acct.c_period_ID	record_id							N		1			..annual fiscal year IDs are known					 * @amtcr@		=H6		fact_acct.amtcr	record_id								Y		1								 * @amtdr@		=G6		fact_acct.amtdr	record_id								Y		1								 * @author red1org@gmail.com Redhuan D. Oon for MOTIVE SOLUTIONS THAILAND	 *	 */
	public class ExpenseReport extends SvrProcess {
		private String File_Directory = "/home/red1/Documents/FactAcctReport.xls"; 		Timestamp DateFrom = null;		Timestamp DateTo = null;		HSSFDataFormatter dataFormatter = new HSSFDataFormatter();
		HSSFWorkbook workbook = new HSSFWorkbook();   		String direction = "";		static String UP = "#^";		static String DOWN = "#V";		static String LEFT = "#<";		static String RIGHT = "#>";		static String END = "END";		int rowtracker = 0;		int coltracker = 0;		String documentno = "";		long start = System.currentTimeMillis();		ArrayList<ValueNamePair> arrayreturn = new ArrayList<ValueNamePair>();		//SET ParameterTag values for #1 From, #2 To			String from = "";		String to = "";		// ...				protected void prepare() {
		ProcessInfoParameter[] para = getParameter();
			for (ProcessInfoParameter p:para) {
				String name = p.getParameterName();
				if (p.getParameter() == null)					;
				else if(name.equals("DateFrom")) 
					DateFrom = p.getParameterAsTimestamp();
			 
				else if(name.equals("DateTo"))					DateTo = p.getParameterAsTimestamp();									else if(name.equals("File_Directory"))					File_Directory = p.getParameterAsString();
			}			if (DateTo!=null)				to=DateTo.toString();			if (DateFrom!=null)				from = DateFrom.toString();
		}				protected String doIt() throws IOException { 			// 			//OBTAIN FACTS +++++			//int[] recordIDs = buildFactsRecordIDs();						//if (recordIDs==null || recordIDs.length==0) 			//	throw new AdempiereException("No Accounting Facts Record");						direction = RIGHT;			FileInputStream file = new FileInputStream(File_Directory); 			workbook = new HSSFWorkbook(file); 			HSSFSheet inputsheet = workbook.getSheet("Input");			HSSFSheet processsheet = workbook.getSheet("Process"); 			HSSFSheet outputsheet = workbook.getSheet("Output");			workbook.setForceFormulaRecalculation(true); 			// 			clearContent(processsheet);			//			setAddress(inputsheet,processsheet); 			//			StringBuilder completeStatement = makeFullSQLStatement(processsheet);			//			List<List<Object>> results = executeSQL(completeStatement);			//			if (results!=null){				set(results,processsheet);				paint(processsheet,outputsheet);			}			//			workbookWrite();			//			long finish = System.currentTimeMillis();			long timeElapsed = finish - start;			
			return results.size()+" Records. Time Elapsed: "+timeElapsed;
		}			private void clearContent(HSSFSheet prsheet) { 			Iterator<Row> rowIteratePr = prsheet.rowIterator(); 				rowIteratePr.next();//skip label header			while (rowIteratePr.hasNext()) {  				int col = 7;				HSSFRow rowPr = (HSSFRow)rowIteratePr.next();//row 2 until END				HSSFCell cellPr = rowPr.getCell(col);				if (cellPr==null)					break;				if (!(cellPr.getCellType()==CellType.NUMERIC) &&  (cellPr.getStringCellValue()).equals("END"))					break; //break when start cell in row is END. 							while (true) {						if (cellPr==null)						break;					if (!(cellPr.getCellType()==CellType.NUMERIC) &&  cellPr.getStringCellValue().equals("END")) {						break;					}					cellPr.setBlank();					col++;					cellPr = rowPr.getCell(col);				}			}		}			/**		 * Get Location on Input Sheet as Address Values in Process Sheet Column 2		 * @param recordIDs 		 * @param sheet		 */		private void setAddress(HSSFSheet insheet,HSSFSheet prsheet) {						Iterator<Row> rowIteratePr = prsheet.rowIterator();  			rowIteratePr.next();//skip label header			while (rowIteratePr.hasNext()) { //loop thru every row				HSSFRow rowPr = (HSSFRow)rowIteratePr.next();					HSSFCell annotate = rowPr.getCell(0); 				if (annotate==null || annotate.toString().isBlank())					break;				if (annotate.equals("@@")) //blank reference					break;				HSSFCell addressPr = rowPr.getCell(1);//Cell to store address of input annotation				if (addressPr==null) {					rowPr.createCell(1);  			//initialize cell if null					addressPr=rowPr.getCell(1);				}				//Search address in input sheet				Iterator<Row> rowIterateIn = insheet.rowIterator(); //go thru input rows				//				while(rowIterateIn.hasNext()) {  					HSSFRow rowIn = (HSSFRow)rowIterateIn.next();						Iterator<Cell> cellIterateIn = rowIn.cellIterator();					while(cellIterateIn.hasNext()) {						HSSFCell cellIn = (HSSFCell) cellIterateIn.next();						if (cellIn.getCellType()==CellType.FORMULA)//formula is not annotation value?							continue;						if (cellIn.toString().equals(annotate.toString())) {							//set to process sheet							addressPr.setCellValue(cellIn.getAddress().toString()); 							//  						 							break;						}						}				}			}		}				/**		 * Formulate a Fully Qualified SQL Statement for Execution		 * @param prsheet		 * @return		 */		private StringBuilder makeFullSQLStatement(HSSFSheet prsheet) {				 			StringBuilder fullSQL 	= new StringBuilder(); 			StringBuilder SELECT 	= new StringBuilder();			StringBuilder TABLE 	= new StringBuilder();			StringBuilder JOIN 		= new StringBuilder(); 			StringBuilder WHERE = new StringBuilder();						boolean gothruall = false;			boolean manynames = false;			boolean hasJoin = false;						Iterator<Row> rowIteratePr = prsheet.rowIterator();  			rowIteratePr.next();//skip label header						while (rowIteratePr.hasNext()) { //loop thru every row				HSSFRow rowPr = (HSSFRow)rowIteratePr.next();									if (rowPr.getCell(2)==null)					break; //Leave, SELECT column ends or empty means no more lines.								if (gothruall) { // #########################################################################					SELECT.append(","+rowPr.getCell(2).toString());					if (rowPr.getCell(3)!=null) {						if (rowPr.getCell(3).toString().contains("JOIN")) { // INNER/LEFT/RIGHT/OUTER JOINS							TABLE.append(" "+rowPr.getCell(3).toString());							if (TABLE.toString().contains(" a,")) //Checking if JOIN has an alias+coma before								throw new AdempiereException("Tables has coma and JOIN: "+TABLE.toString());						}						else {							if (!rowPr.getCell(3).toString().isEmpty())								TABLE.append(","+rowPr.getCell(3).toString());												}						if (rowPr.getCell(4)!=null) {							if (!rowPr.getCell(4).toString().isEmpty())								JOIN.append(" "+rowPr.getCell(4).toString());							}						if (rowPr.getCell(5)!=null) {							if (!rowPr.getCell(5).toString().isEmpty())								WHERE.append(" "+rowPr.getCell(5).toString());							}					}										continue; //picking up more SQL bits				} else // ###################################################################################					SELECT = new StringBuilder(rowPr.getCell(2).toString());									if (rowPr.getCell(3)!=null)					TABLE = new StringBuilder (rowPr.getCell(3).toString());								if (rowPr.getCell(4)!=null)					JOIN = new StringBuilder (rowPr.getCell(4).toString());				 				if (rowPr.getCell(5)!=null)					WHERE = new StringBuilder (rowPr.getCell(5).toString());								if (SELECT.length()>0 && TABLE.length()==0)					manynames = true;								if (!gothruall)					if (TABLE.toString().endsWith(" a")) {						gothruall=true;					}			}			// ############ FORM FULL 					fullSQL.append("SELECT "+SELECT).append(" FROM "+TABLE).append(" WHERE "+JOIN).append(" "+WHERE);			fullSQL = replaceParameterTag(fullSQL, from, to);						return fullSQL;		}				/*				//SELECT STATEMENT EXECUTE +++++ 				StringBuilder whereCondition = new StringBuilder();				if (rowPr.getCell(4)!=null)					whereCondition.append(rowPr.getCell(4).toString());								//setup JOIN TABLES								StringBuilder fromTable = new StringBuilder();				if (rowPr.getCell(3)!=null)					tablestring = rowPr.getCell(3).toString();				else {					//check previous full SQL, fetch returns and break from this										break;				}							String prefix = "";				String[]tables = tablestring.split(",");				for (int t=0 ;t<tables.length;t++) {					char[] ab = "abcdef".toCharArray();					fromTable.append(prefix);					prefix=","; 					fromTable.append(tables[t]+" "+ab[t]);				}				prefix = "";				if (tables.length>1) { 					String[] alias = whereCondition.toString().split(",");					whereCondition = new StringBuilder();					if (alias.length<1)						throw new AdempiereException("JOIN TABLEs has no WHEREs");					for (int a=0; a < alias.length; a++) {						char[]ab = "abcdef".toCharArray();						whereCondition.append(prefix);						prefix=" AND ";						String[] aliasname = alias[a].split("=");						if (aliasname.length==1)							whereCondition.append(aliasname[0]+"=?");						else							whereCondition.append(ab[a]+".")							.append(aliasname[0])							.append("="+ab[a+1])							.append("."+aliasname[1]);					} 				}				else 					fromTable = new StringBuilder(tablestring);								if (whereCondition.toString().equals("")) {						whereCondition = new StringBuilder(rowPr.getCell(5).toString());				}				else if (whereCondition.toString().contains("a."))	{					if (rowPr.getCell(5)!=null && !rowPr.getCell(5).toString().equals("")) 						whereCondition.append(" "+rowPr.getCell(5).toString());					} else {						//whereCondition.append("=?");					}			//	if (whereCondition.toString().contains("=?")) 			//		param[0] = recordIDs[i]; //usual case			//	else			//		param = null; 								whereCondition = replaceParameterTag(whereCondition, from, to);						 								fullSQL = new StringBuilder("SELECT "+SELECT.toString()				+" FROM "+TABLE.append(JOIN).toString()+" WHERE "+WHERE.toString());								List<List<Object>> returns = executeSQL(fullSQL);				//				//handle null returns				if (returns==null || returns.isEmpty() || returns.size()==0) {					System.out.println(fullSQL.toString()+" RETURNS NOTHING");					continue;				}				if (returns.size()==1) {					Object obj = returns.get(0);					if (obj.toString().equals("[0.00]")) 					 		System.out.println(fullSQL.toString()+" RETURNS NOTHING");				}				//SET VALUES TO PROCESS SHEET +++++ LOOP EACH VALUE TO VALUES IN SHEET				setReturnValues(rowPr, returns);		 */	 				private List<List<Object>> executeSQL(StringBuilder SQL) {			List<List<Object>> returns =  DB.getSQLArrayObjectsEx(get_TrxName(),SQL.toString());			if (returns==null || returns.isEmpty() || returns.size()==0) {				System.out.println(SQL.toString()+" RETURNS NOTHING");				return null;			}			if (returns.size()==1) {				Object obj = returns.get(0);				if (obj.toString().equals("[0.00]")) {				 		System.out.println(SQL.toString()+" RETURNS NOTHING");				 		return null;				}			}			return returns;		}	private void set(List<List<Object>> results, HSSFSheet prsheet) {		int v = 7;		for (List<Object> returning:results) { 			Iterator<Row> rowIteratePr = prsheet.rowIterator();  			rowIteratePr.next();//skip label header 							setReturnValues(rowIteratePr, returning, v); 						v++; //column to write returned values starting from 7 to the END		}	}	private void paint(HSSFSheet prsheet, HSSFSheet outsheet) {		//take column "Address" as ready array		Iterator<Row> rowIteratePr = prsheet.rowIterator();  		rowIteratePr.next();//skip label header		while (rowIteratePr.hasNext()) {  			int nc = 7;//column VALUEs start at 7			HSSFRow rowPr = (HSSFRow)rowIteratePr.next(); 			//search address in insheet			HSSFCell addressPr = rowPr.getCell(1); 			if (rowPr.getCell(0)==null)				break;			String annotation = rowPr.getCell(0).toString(); 			if (addressPr==null|| addressPr.toString().isBlank())				continue;			//fetch values from prSheet			CellReference ref = new CellReference(addressPr.getStringCellValue());			Row outrow = outsheet.getRow(ref.getRow());			if (outrow==null)				outrow = outsheet.createRow(ref.getRow());			   Cell outcell = outrow.getCell(ref.getCol());			if (outcell == null) 				outcell = outrow.createCell(ref.getCol());  			//			//holder for row to go DOWN			int downrow = outrow.getRowNum();			Row outwriterow = outrow;						//fetch/write VALUEs to outputsheet    			boolean prValueNotEnd = true;			HSSFCell prValue = rowPr.getCell(nc);			while (prValueNotEnd) {  				if (prValue == null)					break;				if (prValue.toString().equals("END"))					break;								if (prValue.getCellType()==CellType.FORMULA)					continue;				if (prValue.getCellType()==CellType.NUMERIC) { 					   outcell.setCellValue(prValue.getNumericCellValue());							   				   } else {					   outcell.setCellValue(prValue.getStringCellValue());				   }				outcell.setCellStyle(prValue.getCellStyle());								//get next value writing - 				//there is RIGHT AND DOWN direction to display subsequent records				if (annotation.endsWith(DOWN)){ //DOWNWARDS					downrow++;					outwriterow = outsheet.getRow(downrow);					outcell = outwriterow.getCell(outcell.getColumnIndex());					//					if (outwriterow.getCell(outcell.getColumnIndex())==null)						outcell = outwriterow.createCell(outcell.getColumnIndex());					else						outcell = outwriterow.getCell(outcell.getColumnIndex());									} else { //continue RIGHT-WISE					if (outrow.getCell(outcell.getColumnIndex()+1)==null)						outcell = outrow.createCell(outcell.getColumnIndex()+1);					else						outcell = outrow.getCell(outcell.getColumnIndex()+1);				}				nc++;				prValue = rowPr.getCell(nc);				//			}//LOOP OUTCELL WITHIN OUTROW ++++		} 	}	private void workbookWrite() throws IOException {		 		FileOutputStream out = new FileOutputStream(File_Directory);		if(out!=null)		{			workbook.write(out);			out.close();			workbook.close();		}	}			private void setReturnValues(Iterator<Row> rowIteratePr, List<Object> returns, int v) { 		for (Object retValue:returns) {			if (retValue==null)				continue;			if (!rowIteratePr.hasNext())				return;			HSSFRow rowPr = (HSSFRow)rowIteratePr.next();			if (rowPr.getCell(v)==null)				rowPr.createCell(v);			HSSFCell cellPr = rowPr.getCell(v);			// 			String cellValue = dataFormatter.formatCellValue(cellPr); 			if (cellValue.equals("END"))				break;			//get CellValue			 if(cellPr.getCellType() == CellType.FORMULA) { 		          switch(cellPr.getCachedFormulaResultType()) {		            case NUMERIC:		                cellValue= Double.toString(cellPr.getNumericCellValue());		                break;		            case STRING:		                cellValue= cellPr.getRichStringCellValue().getString();		                break;		            case BLANK:		            	break;					case BOOLEAN:						break;					case ERROR:						break;					case FORMULA:						break;					case _NONE:						break;					default:						break;		          }		     }			//check if numeric			 if (retValue instanceof String) { //STRING TYPE ++++				 if (String.valueOf(retValue).equals(cellPr.toString()))					continue;//same string, stop writing further					else {	 							cellPr.setCellValue((String)retValue);						System.out.println(cellPr.getAddress()+" Address is SetCellValue "+retValue);					}			 }else if (retValue instanceof Timestamp) {				 if (retValue.equals(cellPr.getLocalDateTimeCellValue()))						continue;//same string, stop writing further						else {	 								cellPr.setCellValue((Timestamp)retValue); 							System.out.println(cellPr.getAddress()+" Address is SetCellValue "+retValue);						}			 }			 else {//NUMERIC ++++				 double celltotal = cellPr.getNumericCellValue();				 //TODO Accumulate to Same Process Location			 	String str = retValue.toString(); 			 	double d = Double.valueOf(str).doubleValue(); 			 	celltotal = celltotal+d; 				cellPr.setCellValue(celltotal); //for both cases				System.out.println(cellPr.getAddress()+" Address is Numeric "+retValue);					 } 		 } 	}		private StringBuilder replaceParameterTag(StringBuilder whereCondition, String from, String to) {		String s = "";		if (whereCondition.toString().contains("#")){			s = whereCondition.toString().replace("#1","\'"+from+"\'"); 			whereCondition = new StringBuilder(s.replace("#2","\'"+to+"\'"));		}		return whereCondition;	}	private void setArrayReturns(ArrayList<ValueNamePair> arrayreturn, List<List<Object>> returns) {	// TODO Auto-generated method stub		}
}
